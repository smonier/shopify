"use strict";
/*!
This file is part of CycloneDX Webpack plugin.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

SPDX-License-Identifier: Apache-2.0
Copyright (c) OWASP Foundation. All Rights Reserved.
*/
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Extractor_instances, _Extractor_compilation, _Extractor_componentBuilder, _Extractor_purlFactory, _Extractor_linkDependencies;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Extractor = void 0;
const CDX = require("@cyclonedx/cyclonedx-library");
const normalizePackageJson = require("normalize-package-data");
const _helpers_1 = require("./_helpers");
class Extractor {
    constructor(compilation, componentBuilder, purlFactory) {
        _Extractor_instances.add(this);
        _Extractor_compilation.set(this, void 0);
        _Extractor_componentBuilder.set(this, void 0);
        _Extractor_purlFactory.set(this, void 0);
        __classPrivateFieldSet(this, _Extractor_compilation, compilation, "f");
        __classPrivateFieldSet(this, _Extractor_componentBuilder, componentBuilder, "f");
        __classPrivateFieldSet(this, _Extractor_purlFactory, purlFactory, "f");
    }
    generateComponents(modules, logger) {
        const pkgs = {};
        const components = new Map();
        logger?.log('start building Components from modules...');
        for (const module of modules) {
            if (module.context === null) {
                logger?.debug('skipping', module);
                continue;
            }
            const pkg = (0, _helpers_1.getPackageDescription)(module.context);
            if (pkg === undefined) {
                logger?.debug('skipped package for', module.context);
                continue;
            }
            let component = pkgs[pkg.path];
            if (component === undefined) {
                logger?.log('try to build new Component from PkgPath:', pkg.path);
                try {
                    component = this.makeComponent(pkg, logger);
                }
                catch (err) {
                    logger?.debug('unexpected error:', err);
                    logger?.warn('skipped Component from PkgPath', pkg.path);
                    continue;
                }
                logger?.debug('built', component, 'based on', pkg, 'for module', module);
                pkgs[pkg.path] = component;
            }
            components.set(module, component);
        }
        logger?.log('linking Component.dependencies...');
        __classPrivateFieldGet(this, _Extractor_instances, "m", _Extractor_linkDependencies).call(this, components);
        logger?.log('done building Components from modules...');
        return components.values();
    }
    /**
     * @throws {Error} when no component could be fetched
     */
    makeComponent(pkg, logger) {
        try {
            const _packageJson = structuredClonePolyfill(pkg.packageJson);
            normalizePackageJson(_packageJson /* add debug for warnings? */);
            // region fix normalizations
            if (typeof pkg.packageJson.version === 'string') {
                // allow non-SemVer strings
                _packageJson.version = pkg.packageJson.version.trim();
            }
            // endregion fix normalizations
            pkg.packageJson = _packageJson;
        }
        catch (e) {
            logger?.warn('normalizePackageJson from PkgPath', pkg.path, 'failed:', e);
        }
        const component = __classPrivateFieldGet(this, _Extractor_componentBuilder, "f").makeComponent(pkg.packageJson);
        if (component === undefined) {
            throw new Error(`failed building Component from PkgPath ${pkg.path}`);
        }
        component.licenses.forEach(l => {
            l.acknowledgement = CDX.Enums.LicenseAcknowledgement.Declared;
        });
        component.purl = __classPrivateFieldGet(this, _Extractor_purlFactory, "f").makeFromComponent(component);
        component.bomRef.value = component.purl?.toString();
        return component;
    }
}
exports.Extractor = Extractor;
_Extractor_compilation = new WeakMap(), _Extractor_componentBuilder = new WeakMap(), _Extractor_purlFactory = new WeakMap(), _Extractor_instances = new WeakSet(), _Extractor_linkDependencies = function _Extractor_linkDependencies(modulesComponents) {
    for (const [module, component] of modulesComponents) {
        for (const dependencyModule of module.dependencies.map(d => __classPrivateFieldGet(this, _Extractor_compilation, "f").moduleGraph.getModule(d)).filter(isNonNullable)) {
            const dependencyBomRef = modulesComponents.get(dependencyModule)?.bomRef;
            if (dependencyBomRef !== undefined) {
                component.dependencies.add(dependencyBomRef);
            }
        }
    }
};
function isNonNullable(value) {
    // NonNullable: not null and not undefined
    return value !== null && value !== undefined;
}
const structuredClonePolyfill = typeof structuredClone === 'function'
    ? structuredClone
    : function (value) { return JSON.parse(JSON.stringify(value)); };
//# sourceMappingURL=extractor.js.map