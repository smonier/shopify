function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
import React from 'react';
import { Menu, MenuItem, ModalManager } from '@material-ui/core';
import { Translation } from 'react-i18next';
import { componentRendererAction } from './componentRendererAction';
import { composeActions } from './composeActions';
import { DisplayActions } from './DisplayActions';
import { withStylesAction } from './withStylesAction';
import { ArrowRight } from '@material-ui/icons';
import { BehaviorSubject, combineLatest } from 'rxjs';
import { pure } from 'recompose';
import { toIconComponent } from './toIconComponent';
import { ListItemIcon } from '@jahia/design-system-kit';
var styles = {
  modalRoot: {
    pointerEvents: 'none'
  },
  paperRoot: {
    pointerEvents: 'initial'
  },
  loading: {
    opacity: 0
  },
  emptyMenuItem: {
    display: 'none'
  },
  empty: {
    '& $emptyMenuItem': {
      display: 'block'
    }
  },
  noIcon: {
    width: 20,
    height: 20
  }
};
var setActionsRef = function setActionsRef(ref, context) {
  if (ref) {
    if (menuStatus[context.id].menuSubscription) {
      menuStatus[context.id].menuSubscription.unsubscribe();
      delete menuStatus[context.id].menuSubscription;
    }
    menuStatus[context.id].menuSubscription = combineLatest(ref.observerRefs).subscribe(function () {
      if (menuStatus[context.id]) {
        menuStatus[context.id].onMenuLoaded(context.menuDisplayed);
      }
    });
  }
};
var menuStatus = {};
var preload = function preload(context) {
  context.obs = {
    enabled: new BehaviorSubject(false)
  };
  context.enabled = context.obs.enabled;
  var currentPreloadMenuHandler = context.renderComponent( /*#__PURE__*/React.createElement(DisplayActions, {
    target: context.menu,
    context: _objectSpread(_objectSpread({}, context.originalContext), {}, {
      displayDisabled: context.menuDisplayDisabled,
      parent: context
    }),
    render: function render() {
      context.obs.enabled.next(true);
      return false;
    }
  }));
  menuStatus[context.id] = {
    open: false,
    inMenu: false,
    preload: currentPreloadMenuHandler
  };
};
var PureMenu = pure(Menu);
var display = function display(context, anchor) {
  // Disable backdrop for sub menus, click through to main menu backdrop
  var subMenuProps = context.parent ? {
    ModalClasses: {
      root: context.classes.modalRoot
    },
    classes: {
      paper: context.classes.paperRoot
    },
    disableEnforceFocus: true,
    manager: new ModalManager({
      hideSiblingNodes: false
    })
  } : {};
  if (!menuStatus[context.id]) {
    menuStatus[context.id] = {
      open: false,
      inMenu: false
    };
  }
  var showIcons = context.showIcons;
  var noIconClass = context.classes.noIcon;
  menuStatus[context.id].open = true;
  context.currentMenuHandler = context.renderComponent( /*#__PURE__*/React.createElement(PureMenu, _extends({
    open: true,
    className: context.classes.loading,
    id: 'menu-' + context.id
  }, anchor, {
    action: function action(c) {
      menuStatus[context.id].onMenuLoaded = function (displayed) {
        if (menuStatus[context.id].open) {
          c.updatePosition();
          context.currentMenuHandler.setProps({
            className: displayed ? '' : context.classes.empty
          });
        }
      };
    },
    BackdropProps: {
      invisible: true,
      onContextMenu: function onContextMenu(e) {
        e.preventDefault();
        context.currentMenuHandler.setProps({
          open: false
        });
      }
    },
    onClose: function onClose() {
      context.currentMenuHandler.setProps({
        open: false
      });
    },
    onExit: function onExit() {
      menuStatus[context.id].open = false;
      if (context.onExit) {
        context.onExit(context);
      }
      if (menuStatus[context.id].menuSubscription) {
        menuStatus[context.id].menuSubscription.unsubscribe();
        delete menuStatus[context.id].menuSubscription;
      }

      // Close sub menu if they exist
      if (context.currentOpenSubmenuContext) {
        context.currentOpenSubmenuContext.currentMenuHandler.setProps({
          open: false
        });
      }
    },
    onExited: function onExited() {
      // Free resources after exit
      context.currentMenuHandler.destroy();
      delete menuStatus[context.id];
    },
    onMouseEnter: function onMouseEnter() {
      menuStatus[context.id].inMenu = true;
    },
    onMouseLeave: function onMouseLeave() {
      menuStatus[context.id].inMenu = false;
    }
  }, subMenuProps), /*#__PURE__*/React.createElement(Translation, null, function (t) {
    return /*#__PURE__*/React.createElement(React.Fragment, null, context.menuEmptyMessage && /*#__PURE__*/React.createElement(MenuItem, {
      disabled: true,
      classes: {
        root: context.classes.emptyMenuItem
      }
    }, t(context.menuEmptyMessage)), /*#__PURE__*/React.createElement(DisplayActions, {
      ref: function ref(r) {
        return setActionsRef(r, context);
      },
      context: _objectSpread(_objectSpread({}, context.originalContext), {}, {
        displayDisabled: context.menuDisplayDisabled,
        parent: context
      }),
      filter: context.menuFilter,
      render: function render(_ref) {
        var context = _ref.context;
        context.parent.menuDisplayed = true;
        var disabled = context.enabled !== null && context.enabled === false;
        return /*#__PURE__*/React.createElement(MenuItem, {
          "data-sel-role": context.key,
          "data-sel-disabled": disabled,
          disabled: disabled,
          onClick: function onClick(e) {
            // First close all menu by closing main menu
            var rootContext = context;
            while (rootContext.parent && rootContext.parent.currentMenuHandler) {
              rootContext = rootContext.parent;
            }
            rootContext.currentMenuHandler.setProps({
              open: false
            });
            // Send click event
            context.onClick(context, e);
          },
          onMouseEnter: function onMouseEnter(e) {
            // If a submenu was open, close it
            if (context.parent.currentOpenSubmenuContext) {
              context.parent.currentOpenSubmenuContext.currentMenuHandler.setProps({
                open: false
              });
            }

            // Send mouseEnter event
            if (context.onMouseEnter) {
              context.onMouseEnter(context, e);
            }
          },
          onMouseLeave: context.onMouseLeave && function (e) {
            context.onMouseLeave(context, e);
          }
        }, showIcons && /*#__PURE__*/React.createElement(ListItemIcon, null, context.buttonIcon ? toIconComponent(context.buttonIcon) : /*#__PURE__*/React.createElement("span", {
          className: noIconClass
        })), /*#__PURE__*/React.createElement("span", {
          dangerouslySetInnerHTML: {
            __html: t(context.buttonLabel, context.buttonLabelParams)
          }
        }), context.icon);
      },
      target: context.menu
    }));
  })));
};
var menuAction = composeActions(componentRendererAction, withStylesAction(styles), {
  init: function init(context) {
    if (!context.icon) {
      context.icon = /*#__PURE__*/React.createElement(ArrowRight, null);
    }
    context.menuDisplayed = false;
    if (context.menuPreload) {
      preload(context);
    }
  },
  destroy: function destroy(context) {
    if (menuStatus[context.id] && menuStatus[context.id].preload) {
      menuStatus[context.id].preload.destroy();
    }
  },
  onMouseEnter: function onMouseEnter(context, e) {
    if (context.parent && menuStatus[context.parent.id].open) {
      // Open submenu on mouseEnter
      context.parent.currentOpenSubmenuContext = context;
      var b = e.currentTarget.getBoundingClientRect();
      display(context, {
        anchorPosition: {
          left: b.left + b.width,
          top: b.top
        },
        anchorReference: 'anchorPosition'
      });
    }
  },
  onMouseLeave: function onMouseLeave(context) {
    if (context.parent && context.parent.currentOpenSubmenuContext) {
      // Close submenu on mouseLeave - first check if the pointer has not left for the menu itself
      setTimeout(function () {
        if ((!menuStatus[context.id] || !menuStatus[context.id].inMenu) && context.parent.currentOpenSubmenuContext && context.parent.currentOpenSubmenuContext.key === context.key) {
          context.parent.currentOpenSubmenuContext.currentMenuHandler.setProps({
            open: false
          });
          context.parent.currentOpenSubmenuContext = null;
        }
      }, 50);
    }
  },
  onClick: function onClick(context, e) {
    // If not a submenu, open it (can be overridden for submenu, as menu is opened on mouseEnter)
    if (!context.parent) {
      var b = e.currentTarget.getBoundingClientRect();
      display(context, {
        anchorPosition: {
          left: b.left,
          top: b.top
        },
        anchorReference: 'anchorPosition'
      });
    }
  },
  onContextMenu: function onContextMenu(context, e) {
    e.preventDefault();
    display(context, {
      anchorPosition: {
        left: e.clientX,
        top: e.clientY
      },
      anchorReference: 'anchorPosition'
    });
  }
});
export { menuAction };